# 设计

让我们首先研究一下我们的敌人的结构。双向链表在概念上很简单，但这就是它为什么会欺骗和误导你。双向链表就是我们反复看过的那种链表，但链接是双向的。双倍的链接，双倍的邪恶。

所以，相比于单向链表这样 (为了看得更清楚，省略 Some/None 之类的东西):

```text
... -> (A, ptr) -> (B, ptr) -> ...
```

现在是这样:

```text
... <-> (ptr, A, ptr) <-> (ptr, B, ptr) <-> ...
```

这让你可以从任何一个方向遍历链表，或者用[cursor](https://doc.rust-lang.org/std/collections/struct.LinkedList.html#method.cursor_back_mut)来回寻找。

作为对这种灵活性的代价，每个节点必须存储两倍的指针，每个操作必须考虑更多的指针。这是一个足够复杂的问题，因此更容易出错，所以我们要做大量的测试。

你可能还注意到，我故意没有画出链表的 *末端*。这是因为末端是我们有正当的理由来选择不同实现方式的地方之一。我们*确信*我们的实现有两个指针：一个指向链表的开始，另一个指向链表的末尾。

在我看来，有两种值得注意的实现方法。"传统的" 和 "假节点" (dummy node)。

传统的方法是我们实现 Stack 的方法的简单扩展 &mdash; 只需在栈上存储头部和尾部的指针。

```text
[ptr, ptr] <-> (ptr, A, ptr) <-> (ptr, B, ptr)
  ^                                        ^
  +----------------------------------------+
```

这种方式很好，但它有一个缺点：极端情况(corner cases)。现在我们的链表上有两条边，这意味着两倍的极端情况。很容易忘记，从而产生一个严重的错误。

假节点的方法是在我们的链表中添加一个额外的节点，这个节点不包含任何数据，但将链表两端连接成一个环，以此试图统一处理这些极端情况。

```text
[ptr] -> (ptr, ?DUMMY?, ptr) <-> (ptr, A, ptr) <-> (ptr, B, ptr)
           ^                                                 ^
           +-------------------------------------------------+ 
```

这样做，每个节点 *总是* 有指针指向链表中的上一个和下一个节点。即使你从链表中删除了最后一个元素，你也只是把假的节点缝合起来指向自己。

```text
[ptr] -> (ptr, ?DUMMY?, ptr) 
           ^             ^
           +-------------+
```

我一定程度上认为这*非常*令人满意和优雅。不幸的是，它有几个实际问题:

问题1：一个额外的指令和分配，特别是对于空链表，它必须包括假节点。可能的解决方案包括:

* 在有东西插入之前不要分配假节点：简单而有效，但它又增加了一些极端情况, 这本来是我们试图通过使用假指针来避免的!

* 使用一个静态的 copy-on-write 的空的单个假节点，用一些非常聪明的方法让 copy-on-write 的检查捎带上正常的检查：看，我真的很想，我真的很喜欢那玩意，但我们不能在这本书里走那条黑暗的路。如果你想看那种变态的东西，请阅读[ThinVec's sourcecode](https://docs.rs/thin-vec/0.2.4/src/thin_vec/lib.rs.html#319-325)的源代码。

* 将假节点存储在栈中 - 在没有 C++ 风格的移动结构的语言中不实用。我相信在这里我们可以用[pinning](https://doc.rust-lang.org/std/pin/index.html)做一些奇怪的事情，但我们不会这样做的。

问题2：假节点中存储的是什么 *值*？当然，如果是一个整数就没问题，但如果我们存储的是一个充满 `Box` 的链表呢？我们可能不能初始化这个值! 潜在的解决方案包括:

* 让每个节点都存储`Option<T>`：简单有效，但也很臃肿和烦人。

* 让每个节点都存储 [`MaybeUninit<T>`](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html)。骇人听闻，令人厌烦。

* 使用*非常*小心、聪明的继承式类型双关，这样假的节点就不包括数据字段。这也是很诱人的，但它是极其危险和恼人的。如果你想看那种变态的东西，请阅读 [BTreeMap's source](https://doc.rust-lang.org/1.55.0/src/alloc/collections/btree/node.rs.html#49-104)的源代码。

对于像 Rust 这样的语言来说，这些方法带来的问题比简化的东西更多，所以我们要坚持使用传统的布局。我们将使用与上一章中的不安全队列相同的基本设计。

```rust
pub struct LinkedList<T> {
    front: Link<T>,
    back: Link<T>,
    len: usize,
}

type Link<T> = *mut Node<T>;

struct Node<T> {
    front: Link<T>,
    back: Link<T>,
    elem: T, 
}
```

(现在，我们到了双向链表队列这一步，我们终于赢得了称自己为 LinkedList 的权利，因为这才是真正的 Linked List）。

这还不是一个*真正的*产品级的布局。这很*不错*，但是我们可以用一些魔术来更好地告诉 Rust 我们正在做的事情。要做到这一点，我们需要......更深入。
