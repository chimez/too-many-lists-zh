<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Implementing Cursors - Learning Rust With Entirely Too Many Linked Lists</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learning Rust With Entirely Too Many Linked Lists">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="first.html"><strong aria-hidden="true">2.</strong> A Bad Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="first-layout.html"><strong aria-hidden="true">2.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="first-new.html"><strong aria-hidden="true">2.2.</strong> New</a></li><li class="chapter-item expanded "><a href="first-ownership.html"><strong aria-hidden="true">2.3.</strong> Ownership 101</a></li><li class="chapter-item expanded "><a href="first-push.html"><strong aria-hidden="true">2.4.</strong> Push</a></li><li class="chapter-item expanded "><a href="first-pop.html"><strong aria-hidden="true">2.5.</strong> Pop</a></li><li class="chapter-item expanded "><a href="first-test.html"><strong aria-hidden="true">2.6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="first-drop.html"><strong aria-hidden="true">2.7.</strong> Drop</a></li><li class="chapter-item expanded "><a href="first-final.html"><strong aria-hidden="true">2.8.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="second.html"><strong aria-hidden="true">3.</strong> An Ok Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="second-option.html"><strong aria-hidden="true">3.1.</strong> Option</a></li><li class="chapter-item expanded "><a href="second-generic.html"><strong aria-hidden="true">3.2.</strong> Generic</a></li><li class="chapter-item expanded "><a href="second-peek.html"><strong aria-hidden="true">3.3.</strong> Peek</a></li><li class="chapter-item expanded "><a href="second-into-iter.html"><strong aria-hidden="true">3.4.</strong> IntoIter</a></li><li class="chapter-item expanded "><a href="second-iter.html"><strong aria-hidden="true">3.5.</strong> Iter</a></li><li class="chapter-item expanded "><a href="second-iter-mut.html"><strong aria-hidden="true">3.6.</strong> IterMut</a></li><li class="chapter-item expanded "><a href="second-final.html"><strong aria-hidden="true">3.7.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="third.html"><strong aria-hidden="true">4.</strong> A Persistent Stack</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="third-layout.html"><strong aria-hidden="true">4.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="third-basics.html"><strong aria-hidden="true">4.2.</strong> Basics</a></li><li class="chapter-item expanded "><a href="third-drop.html"><strong aria-hidden="true">4.3.</strong> Drop</a></li><li class="chapter-item expanded "><a href="third-arc.html"><strong aria-hidden="true">4.4.</strong> Arc</a></li><li class="chapter-item expanded "><a href="third-final.html"><strong aria-hidden="true">4.5.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="fourth.html"><strong aria-hidden="true">5.</strong> A Bad Safe Deque</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fourth-layout.html"><strong aria-hidden="true">5.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="fourth-building.html"><strong aria-hidden="true">5.2.</strong> Building</a></li><li class="chapter-item expanded "><a href="fourth-breaking.html"><strong aria-hidden="true">5.3.</strong> Breaking</a></li><li class="chapter-item expanded "><a href="fourth-peek.html"><strong aria-hidden="true">5.4.</strong> Peek</a></li><li class="chapter-item expanded "><a href="fourth-symmetry.html"><strong aria-hidden="true">5.5.</strong> Symmetric Cases</a></li><li class="chapter-item expanded "><a href="fourth-iteration.html"><strong aria-hidden="true">5.6.</strong> Iteration</a></li><li class="chapter-item expanded "><a href="fourth-final.html"><strong aria-hidden="true">5.7.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="fifth.html"><strong aria-hidden="true">6.</strong> An Ok Unsafe Queue</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="fifth-layout.html"><strong aria-hidden="true">6.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="fifth-unsafe.html"><strong aria-hidden="true">6.2.</strong> Unsafe</a></li><li class="chapter-item expanded "><a href="fifth-basics.html"><strong aria-hidden="true">6.3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="fifth-miri.html"><strong aria-hidden="true">6.4.</strong> Miri</a></li><li class="chapter-item expanded "><a href="fifth-stacked-borrows.html"><strong aria-hidden="true">6.5.</strong> Stacked Borrows</a></li><li class="chapter-item expanded "><a href="fifth-testing-stacked-borrows.html"><strong aria-hidden="true">6.6.</strong> Testing Stacked Borrows</a></li><li class="chapter-item expanded "><a href="fifth-layout-basics-redux.html"><strong aria-hidden="true">6.7.</strong> Layout + Basics Redux</a></li><li class="chapter-item expanded "><a href="fifth-extras.html"><strong aria-hidden="true">6.8.</strong> Extras</a></li><li class="chapter-item expanded "><a href="fifth-final.html"><strong aria-hidden="true">6.9.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="sixth.html"><strong aria-hidden="true">7.</strong> A Production Unsafe Deque</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sixth-layout.html"><strong aria-hidden="true">7.1.</strong> Layout</a></li><li class="chapter-item expanded "><a href="sixth-variance.html"><strong aria-hidden="true">7.2.</strong> Variance and Subtyping</a></li><li class="chapter-item expanded "><a href="sixth-basics.html"><strong aria-hidden="true">7.3.</strong> Basics</a></li><li class="chapter-item expanded "><a href="sixth-panics.html"><strong aria-hidden="true">7.4.</strong> Panic Safety</a></li><li class="chapter-item expanded "><a href="sixth-combinatorics.html"><strong aria-hidden="true">7.5.</strong> Boring Combinatorics</a></li><li class="chapter-item expanded "><a href="sixth-random-bits.html"><strong aria-hidden="true">7.6.</strong> Filling In Random Bits</a></li><li class="chapter-item expanded "><a href="sixth-testing.html"><strong aria-hidden="true">7.7.</strong> Testing</a></li><li class="chapter-item expanded "><a href="sixth-send-sync.html"><strong aria-hidden="true">7.8.</strong> Send, Sync, and Compile Tests</a></li><li class="chapter-item expanded "><a href="sixth-cursors-intro.html"><strong aria-hidden="true">7.9.</strong> An Introduction To Cursors</a></li><li class="chapter-item expanded "><a href="sixth-cursors-impl.html" class="active"><strong aria-hidden="true">7.10.</strong> Implementing Cursors</a></li><li class="chapter-item expanded "><a href="sixth-cursors-testing.html"><strong aria-hidden="true">7.11.</strong> Testing Cursors</a></li><li class="chapter-item expanded "><a href="sixth-final.html"><strong aria-hidden="true">7.12.</strong> Final Code</a></li></ol></li><li class="chapter-item expanded "><a href="infinity.html"><strong aria-hidden="true">8.</strong> A Bunch of Silly Lists</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="infinity-double-single.html"><strong aria-hidden="true">8.1.</strong> The Double Single</a></li><li class="chapter-item expanded "><a href="infinity-stack-allocated.html"><strong aria-hidden="true">8.2.</strong> The Stack-Allocated Linked List</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learning Rust With Entirely Too Many Linked Lists</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-unofficial/too-many-lists" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="实现光标"><a class="header" href="#实现光标">实现光标</a></h1>
<p>好的，所以我们只打算用std的CursorMut来处理，因为不可变的版本实际上并不有趣。就像我最初的设计一样，它有一个包含None的 &quot;幽灵&quot; 元素来表示列表的开始/结束，你可以 &quot;走过它&quot; 来环绕到列表的另一边。为了实现它，我们将需要:</p>
<ul>
<li>一个指向当前节点的指针</li>
<li>一个指向列表的指针</li>
<li>当前的索引</li>
</ul>
<p>等等，当我们指向 &quot;幽灵&quot; 的时候，索引是什么？</p>
<p><em>眉头紧皱</em> ... <em>检查std</em> ... <em>不喜欢std的答案</em></p>
<p>好吧，很合理地，游标上的<code>index</code>返回一个<code>Option&lt;usize&gt;</code>。std的实现做了一堆垃圾来避免将其存储为一个Option，但是......我们是一个链表，这很好。std 也有  cursor_front/cursor_back 的东西，它在前面/后面的元素上启动光标，这感觉很直观，但是当列表为空时，必须做一些奇怪的事情。</p>
<p>如果你想的话，你可以实现这些东西，但是我打算减少所有重复的垃圾和极端的情况，只做一个光秃秃的<code>cursor_mut</code>方法，从幽灵开始，人们可以使用 move_next/move_prev 来获得他们想要的（如果你真的想的话，你可以把它包起来作为cursor_front）。</p>
<p>让我们开始行动吧:</p>
<pre><code class="language-rust  ignore">pub struct CursorMut&lt;'a, T&gt; {
    cur: Link&lt;T&gt;,
    list: &amp;'a mut LinkedList&lt;T&gt;,
    index: Option&lt;usize&gt;,
}
</code></pre>
<p>很直接，我们的列表中的每一个项目都有一个字段。现在是<code>cursor_mut</code>方法:</p>
<pre><code class="language-rust  ignore">impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn cursor_mut(&amp;mut self) -&gt; CursorMut&lt;T&gt; {
        CursorMut { 
            list: self, 
            cur: None, 
            index: None,
        }
    }
}
</code></pre>
<p>既然我们从幽灵开始，我们就可以从一切都 None 开始，很好，很简单! 接下来是移动：</p>
<pre><code class="language-rust  ignore">impl&lt;'a, T&gt; CursorMut&lt;'a, T&gt; {
    pub fn index(&amp;self) -&gt; Option&lt;usize&gt; {
        self.index
    }

    pub fn move_next(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its next (back)
                self.cur = (*cur.as_ptr()).back;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() += 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real front, so move to it!
            self.cur = self.list.front;
            self.index = Some(0)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }
}
</code></pre>
<p>所以有4种有趣的情况。</p>
<ul>
<li>正常的情况</li>
<li>正常的情况，但我们到达了幽灵的位置</li>
<li>幽灵的情况，我们走到了列表的前面</li>
<li>幽灵的情况，但是列表是空的，所以什么都不做</li>
</ul>
<p>move_prev 是完全相同的逻辑，但是前后颠倒了，索引变化也颠倒了:</p>
<pre><code class="language-rust  ignore">pub fn move_prev(&amp;mut self) {
    if let Some(cur) = self.cur {
        unsafe {
            // We're on a real element, go to its previous (front)
            self.cur = (*cur.as_ptr()).front;
            if self.cur.is_some() {
                *self.index.as_mut().unwrap() -= 1;
            } else {
                // We just walked to the ghost, no more index
                self.index = None;
            }
        }
    } else if !self.list.is_empty() {
        // We're at the ghost, and there is a real back, so move to it!
        self.cur = self.list.back;
        self.index = Some(self.list.len - 1)
    } else {
        // We're at the ghost, but that's the only element... do nothing.
    }
}
</code></pre>
<p>接下来让我们添加一些方法来查看光标周围的元素：current, peek_next, 和 peek_prev。**非常重要的标注：**这些方法必须通过<code>&amp;mut self</code> 来借用我们的光标，而且结果必须与该借用相联系。我们不能让用户得到一个可变引用的多个副本，也不能让他们在抓着这样的引用时使用我们的任何插入/删除/拆分/分片的API!</p>
<p>值得庆幸的是，当你使用生命周期消除时，这是Rust的默认假设，所以，我们将默认做正确的事情!</p>
<pre><code class="language-rust  ignore">pub fn current(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur.map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}

pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).back)
            .map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}

pub fn peek_prev(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    unsafe {
        self.cur
            .and_then(|node| (*node.as_ptr()).front)
            .map(|node| &amp;mut (*node.as_ptr()).elem)
    }
}
</code></pre>
<p>头部为空，Option 方法和（省略的）编译器错误现在都在思考。我对<code>Option&lt;NonNull&gt;</code>的东西持怀疑态度，但是，该死的它真的让我自动驾驶这段代码。 我花了太多的时间来写基于数组的数据结构，在那里你从来没有使用过Option，哇，这真好！&quot;。(<code>(*node.as_ptr())</code>还是很惨的，但是，这只是Rust的原始指针...)</p>
<p>接下来我们有一个选择：我们可以直接跳到分割和拼接，这就是这些API的全部意义，或者我们可以在单元素插入/移除方面采取一个小步骤。我有一种感觉，我们只是想在分割和拼接方面实现插入/删除，所以......让我们先做这些，看看结果如何（当我写到这里的时候，我真的不知道）。</p>
<h1 id="拆分"><a class="header" href="#拆分">拆分</a></h1>
<p>首先是 split_before 和 split_after, 它们将当前元素之前/之后的所有内容作为 LinkedList 返回（在幽灵元素处停止，除非你在幽灵处，在这种情况下，我们只是返回整个List，并且光标现在指向一个空列表）。</p>
<p><em>斜眼看</em> 好的，这个实际上是一些不简单的逻辑，所以我们必须一步一步地谈出来。</p>
<p>我看到split_before有4种潜在的有趣情况。</p>
<ul>
<li>正常情况</li>
<li>正常情况，但prev是幽灵</li>
<li>幽灵情况，我们返回整个列表，成为空的。</li>
<li>幽灵情况，但是列表是空的，所以什么都不做，返回空列表</li>
</ul>
<p>让我们从极端情况开始。第三种情况我认为就是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mem::replace(self.list, LinkedList::new())
<span class="boring">}
</span></code></pre></pre>
<p>对吗？我们变成了空的，我们返回整个列表，而且我们的字段已经是 None，所以没有什么可更新的。很好。哦，嘿嘿，这也是在第四种情况下做的正确的事情!</p>
<p>现在是正常情况......好吧，我需要一些ASCII图来说明。在最一般的情况下，我们有这样的东西:</p>
<pre><code class="language-text">list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
                          ^
                         cur
</code></pre>
<p>而我们想要产生这个:</p>
<pre><code class="language-text">list.front -&gt; C &lt;-&gt; D &lt;- list.back
              ^
             cur

return.front -&gt; A &lt;-&gt; B &lt;- return.back
</code></pre>
<p>所以我们需要打破cur和prev之间的联系，而且......上帝啊，需要改变的东西太多了。好吧，我只需要把这分成几个步骤，这样我就能说服自己这是有意义的。这将是一个有点过于冗长，但我至少可以让它有意义:</p>
<pre><code class="language-rust  ignore">pub fn split_before(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
    if let Some(cur) = self.cur {
        // We are pointing at a real element, so the list is non-empty.
        unsafe {
            // Current state
            let old_len = self.list.len;
            let old_idx = self.index.unwrap();
            let prev = (*cur.as_ptr()).front;
            
            // What self will become
            let new_len = old_len - old_idx;
            let new_front = self.cur;
            let new_back = self.list.back;
            let new_idx = Some(0);

            // What the output will become
            let output_len = old_len - new_len;
            let output_front = self.list.front;
            let output_back = prev;

            // Break the links between cur and prev
            if let Some(prev) = prev {
                (*cur.as_ptr()).front = None;
                (*prev.as_ptr()).back = None;
            }

            // Produce the result:
            self.list.len = new_len;
            self.list.front = new_front;
            self.list.back = new_back;
            self.index = new_idx;

            LinkedList {
                front: output_front,
                back: output_back,
                len: output_len,
                _boo: PhantomData,
            }
        }
    } else {
        // We're at the ghost, just replace our list with an empty one.
        // No other state needs to be changed.
        std::mem::replace(self.list, LinkedList::new())
    }
}
</code></pre>
<p>注意：这些 if-let 处理“正常情况，但是 prev 是幽灵” 的情况:</p>
<pre><code class="language-rust  ignore">if let Some(prev) = prev {
    (*cur.as_ptr()).front = None;
    (*prev.as_ptr()).back = None;
}
</code></pre>
<p>如果<em>你</em>想，你可以把这一切都压缩住，然后做优化，比如:</p>
<ul>
<li>把两次访问 <code>(*cur.as_ptr()).front</code> 写成 <code>(*cur.as_ptr()).front.take()</code> </li>
<li>注意，new_back 是一个 noop ，并删除这两个</li>
</ul>
<p>就我所知，其他的都是顺便做了正确的事情。当我们写测试时，我们会看到! (复制粘贴实现 split_after)</p>
<p>我已经不再犯错了，我只想尽力写出最完美的代码。这就是我<em>实际</em>写数据结构的方法：只是把事情分解成琐碎的步骤和案例，直到它能在我的脑海中出现，并且看起来万无一失。然后写一大堆的测试，直到我确信我没有把它搞乱。</p>
<p>因为我所做的大多数数据结构工作都是<em>极端不安全的</em>，我一般不会依靠编译器来捕捉错误，而 Miri 在当时并不存在！所以我只需要眯着眼睛看，直到我头疼，并尽力做到永远不犯错。</p>
<p>不要写不安全的Rust代码! 安全的Rust是如此的好!!!!</p>
<h1 id="拼接"><a class="header" href="#拼接">拼接</a></h1>
<p>只剩下一个boss要打，就是 splice_before 和 splice_after，我预期这是最棘手的。这两个函数 <em>接收</em> 一个 LinkedList, 并将其内容移植到 outrs 中。我们的列表可能是空的，他们的列表可能是空的，我们有鬼魂要处理......。<em>叹气</em> 让我们用 splice_before 一步步来吧.</p>
<ul>
<li>如果他们的列表是空的，我们就不需要做任何事情。</li>
<li>如果我们的列表是空的，那么我们的列表就成为他们的列表。</li>
<li>如果我们指向鬼魂，那么这就会追加到后面（改变list.back）。</li>
<li>如果我们指向第一个元素(0)，这个就追加到前面(change list.front)</li>
<li>在正常情况下，我们做一大堆的指针操作。</li>
</ul>
<p>一般情况下是这样的:</p>
<pre><code class="language-text">input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back

 list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
                     ^
                    cur
</code></pre>
<p>成为这样:</p>
<pre><code class="language-text">list.front -&gt; A &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; B &lt;-&gt; C &lt;- list.back
</code></pre>
<p>好吗？好的。让我们把它写出来... <em>大口大口地呼吸，然后投身其中</em>:</p>
<pre><code class="language-rust  ignore">    pub fn splice_before(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        unsafe {
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                if let Some(0) = self.index {
                    // We're appending to the front, see append to back
                    (*cur.as_ptr()).front = input.back.take();
                    (*input.back.unwrap().as_ptr()).back = Some(cur);
                    self.list.front = input.front.take();

                    // Index moves forward by input length
                    *self.index.as_mut().unwrap() += input.len;
                    self.list.len += input.len;
                    input.len = 0;
                } else {
                    // General Case, no boundaries, just internal fixups
                    let prev = (*cur.as_ptr()).front.unwrap();
                    let in_front = input.front.take().unwrap();
                    let in_back = input.back.take().unwrap();

                    (*prev.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(prev);
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);

                    // Index moves forward by input length
                    *self.index.as_mut().unwrap() += input.len;
                    self.list.len += input.len;
                    input.len = 0;
                }
            } else if let Some(back) = self.list.back {
                // We're on the ghost but non-empty, append to the back
                // We can either `take` the input's pointers or `mem::forget`
                // it. Using take is more responsible in case we do custom
                // allocators or something that also needs to be cleaned up!
                (*back.as_ptr()).back = input.front.take();
                (*input.front.unwrap().as_ptr()).front = Some(back);
                self.list.back = input.back.take();
                self.list.len += input.len;
                // Not necessary but Polite To Do
                input.len = 0;
            } else {
                // We're empty, become the input, remain on the ghost
                *self.list = input;
            }
        }
    }
</code></pre>
<p>好吧，这个确实很可怕，现在真的感觉到了<code>Option&lt;NonNull&gt;</code>的痛苦。但是我们可以做很多清理工作。首先，我们可以把这段代码拉到最后，因为我们一直想这么做。我不<em>爱</em>（虽然有时是个noop，而设置<code>input.len</code>更多的是对未来代码扩展的偏执）。</p>
<pre><code class="language-rust  ignore">self.list.len += input.len;
input.len = 0;
</code></pre>
<blockquote>
<p>移动值的使用：<code>input</code>。</p>
</blockquote>
<p>啊，对了，在 &quot;我们是空的&quot; 情况下，我们正在移动列表。让我们用交换来代替它:</p>
<pre><code class="language-rust  ignore">// We're empty, become the input, remain on the ghost
std::mem::swap(self.list, &amp;mut input);
</code></pre>
<p>在这种情况下，写法将是无指针的，但是，它们仍然可以工作（我们可能也可以在这个分支中提前返回以安抚编译器）。</p>
<p>这种 unwrap 只是我对案例进行反向思考的结果，可以通过让 if-let 提出正确的问题来解决:</p>
<pre><code class="language-rust  ignore">if let Some(0) = self.index {

} else {
    let prev = (*cur.as_ptr()).front.unwrap();
}
</code></pre>
<p>调整索引是在分支内部重复进行的，所以也可以取出来:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>*self.index.as_mut().unwrap() += input.len;
<span class="boring">}
</span></code></pre></pre>
<p>好吧，把这一切放在一起，我们得到这个:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if input.is_empty() {
    // Input is empty, do nothing.
} else if let Some(cur) = self.cur {
    // Both lists are non-empty
    if let Some(prev) = (*cur.as_ptr()).front {
        // General Case, no boundaries, just internal fixups
        let in_front = input.front.take().unwrap();
        let in_back = input.back.take().unwrap();

        (*prev.as_ptr()).back = Some(in_front);
        (*in_front.as_ptr()).front = Some(prev);
        (*cur.as_ptr()).front = Some(in_back);
        (*in_back.as_ptr()).back = Some(cur);
    } else {
        // We're appending to the front, see append to back below
        (*cur.as_ptr()).front = input.back.take();
        (*input.back.unwrap().as_ptr()).back = Some(cur);
        self.list.front = input.front.take();
    }
    // Index moves forward by input length
    *self.index.as_mut().unwrap() += input.len;
} else if let Some(back) = self.list.back {
    // We're on the ghost but non-empty, append to the back
    // We can either `take` the input's pointers or `mem::forget`
    // it. Using take is more responsible in case we do custom
    // allocators or something that also needs to be cleaned up!
    (*back.as_ptr()).back = input.front.take();
    (*input.front.unwrap().as_ptr()).front = Some(back);
    self.list.back = input.back.take();

} else {
    // We're empty, become the input, remain on the ghost
    std::mem::swap(self.list, &amp;mut input);
}

self.list.len += input.len;
// Not necessary but Polite To Do
input.len = 0;

// Input dropped here
<span class="boring">}
</span></code></pre></pre>
<p>好吧，这仍然很糟糕，但主要是因为 -- 不，好吧，只是发现了一个 bug:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    (*back.as_ptr()).back = input.front.take();
    (*input.front.unwrap().as_ptr()).front = Some(back);
<span class="boring">}
</span></code></pre></pre>
<p>我们 <code>take</code> input.front，然后在下一行把它 unwrap! <em>叹气</em>，我们在同样的镜像情况下做同样的事情。 我们本来可以在测试中立即发现这个问题， 但是， 我们现在正在努力做到完美， 而我只是在现场就做这个，这正是我看到它的时刻。这就是我没有像往常一样乏味，分阶段做事情的结果。更加明确!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// We can either `take` the input's pointers or `mem::forget`
// it. Using `take` is more responsible in case we ever do custom
// allocators or something that also needs to be cleaned up!
if input.is_empty() {
    // Input is empty, do nothing.
} else if let Some(cur) = self.cur {
    // Both lists are non-empty
    let in_front = input.front.take().unwrap();
    let in_back = input.back.take().unwrap();

    if let Some(prev) = (*cur.as_ptr()).front {
        // General Case, no boundaries, just internal fixups
        (*prev.as_ptr()).back = Some(in_front);
        (*in_front.as_ptr()).front = Some(prev);
        (*cur.as_ptr()).front = Some(in_back);
        (*in_back.as_ptr()).back = Some(cur);
    } else {
        // No prev, we're appending to the front
        (*cur.as_ptr()).front = Some(in_back);
        (*in_back.as_ptr()).back = Some(cur);
        self.list.front = Some(in_front);
    }
    // Index moves forward by input length
    *self.index.as_mut().unwrap() += input.len;
} else if let Some(back) = self.list.back {
    // We're on the ghost but non-empty, append to the back
    let in_front = input.front.take().unwrap();
    let in_back = input.back.take().unwrap();

    (*back.as_ptr()).back = Some(in_front);
    (*in_front.as_ptr()).front = Some(back);
    self.list.back = Some(in_back);
} else {
    // We're empty, become the input, remain on the ghost
    std::mem::swap(self.list, &amp;mut input);
}

self.list.len += input.len;
// Not necessary but Polite To Do
input.len = 0;

// Input dropped here
<span class="boring">}
</span></code></pre></pre>
<p>好了，现在这个，这个我可以容忍。我唯一的抱怨是，我们没有 in_front/in_back 进行重复计算（也许我们可以重新调整我们的条件，但不管怎样）。真的，这基本上就是你在C语言中写的东西，但是<code>Option&lt;NonNull&gt;</code>的垃圾让它变得很乏味。我可以接受这一点。好吧，我们应该让原始指针更好地用于这些东西。但是，超出了本书的范围。</p>
<p>总之，我已经精疲力尽了，所以，<code>insert</code> 和 <code>remove</code> 以及所有其他的API可以留给读者作为练习。</p>
<p>这是我们光标的最终代码，我试图复制粘贴组合代码。我做得对吗？只有当我写下一章并测试这个怪胎时才会知道!</p>
<pre><code class="language-rust  ignore">pub struct CursorMut&lt;'a, T&gt; {
    list: &amp;'a mut LinkedList&lt;T&gt;,
    cur: Link&lt;T&gt;,
    index: Option&lt;usize&gt;,
}

impl&lt;T&gt; LinkedList&lt;T&gt; {
    pub fn cursor_mut(&amp;mut self) -&gt; CursorMut&lt;T&gt; {
        CursorMut { 
            list: self, 
            cur: None, 
            index: None,
        }
    }
}

impl&lt;'a, T&gt; CursorMut&lt;'a, T&gt; {
    pub fn index(&amp;self) -&gt; Option&lt;usize&gt; {
        self.index
    }

    pub fn move_next(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its next (back)
                self.cur = (*cur.as_ptr()).back;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() += 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real front, so move to it!
            self.cur = self.list.front;
            self.index = Some(0)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn move_prev(&amp;mut self) {
        if let Some(cur) = self.cur {
            unsafe {
                // We're on a real element, go to its previous (front)
                self.cur = (*cur.as_ptr()).front;
                if self.cur.is_some() {
                    *self.index.as_mut().unwrap() -= 1;
                } else {
                    // We just walked to the ghost, no more index
                    self.index = None;
                }
            }
        } else if !self.list.is_empty() {
            // We're at the ghost, and there is a real back, so move to it!
            self.cur = self.list.back;
            self.index = Some(self.list.len - 1)
        } else {
            // We're at the ghost, but that's the only element... do nothing.
        }
    }

    pub fn current(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.cur.map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn peek_next(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.cur
                .and_then(|node| (*node.as_ptr()).back)
                .map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn peek_prev(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
        unsafe {
            self.cur
                .and_then(|node| (*node.as_ptr()).front)
                .map(|node| &amp;mut (*node.as_ptr()).elem)
        }
    }

    pub fn split_before(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
        // We have this:
        //
        //     list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
        //                               ^
        //                              cur
        // 
        //
        // And we want to produce this:
        // 
        //     list.front -&gt; C &lt;-&gt; D &lt;- list.back
        //                   ^
        //                  cur
        //
        // 
        //    return.front -&gt; A &lt;-&gt; B &lt;- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let prev = (*cur.as_ptr()).front;
                
                // What self will become
                let new_len = old_len - old_idx;
                let new_front = self.cur;
                let new_back = self.list.back;
                let new_idx = Some(0);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = self.list.front;
                let output_back = prev;

                // Break the links between cur and prev
                if let Some(prev) = prev {
                    (*cur.as_ptr()).front = None;
                    (*prev.as_ptr()).back = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn split_after(&amp;mut self) -&gt; LinkedList&lt;T&gt; {
        // We have this:
        //
        //     list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;-&gt; D &lt;- list.back
        //                         ^
        //                        cur
        // 
        //
        // And we want to produce this:
        // 
        //     list.front -&gt; A &lt;-&gt; B &lt;- list.back
        //                         ^
        //                        cur
        //
        // 
        //    return.front -&gt; C &lt;-&gt; D &lt;- return.back
        //
        if let Some(cur) = self.cur {
            // We are pointing at a real element, so the list is non-empty.
            unsafe {
                // Current state
                let old_len = self.list.len;
                let old_idx = self.index.unwrap();
                let next = (*cur.as_ptr()).back;
                
                // What self will become
                let new_len = old_idx + 1;
                let new_back = self.cur;
                let new_front = self.list.front;
                let new_idx = Some(old_idx);

                // What the output will become
                let output_len = old_len - new_len;
                let output_front = next;
                let output_back = self.list.back;

                // Break the links between cur and next
                if let Some(next) = next {
                    (*cur.as_ptr()).back = None;
                    (*next.as_ptr()).front = None;
                }

                // Produce the result:
                self.list.len = new_len;
                self.list.front = new_front;
                self.list.back = new_back;
                self.index = new_idx;

                LinkedList {
                    front: output_front,
                    back: output_back,
                    len: output_len,
                    _boo: PhantomData,
                }
            }
        } else {
            // We're at the ghost, just replace our list with an empty one.
            // No other state needs to be changed.
            std::mem::replace(self.list, LinkedList::new())
        }
    }

    pub fn splice_before(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        // We have this:
        //
        // input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -&gt; A &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                                 ^
        //                                cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(prev) = (*cur.as_ptr()).front {
                    // General Case, no boundaries, just internal fixups
                    (*prev.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(prev);
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                } else {
                    // No prev, we're appending to the front
                    (*cur.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(cur);
                    self.list.front = Some(in_front);
                }
                // Index moves forward by input length
                *self.index.as_mut().unwrap() += input.len;
            } else if let Some(back) = self.list.back {
                // We're on the ghost but non-empty, append to the back
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*back.as_ptr()).back = Some(in_front);
                (*in_front.as_ptr()).front = Some(back);
                self.list.back = Some(in_back);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &amp;mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;
            
            // Input dropped here
        }        
    }

    pub fn splice_after(&amp;mut self, mut input: LinkedList&lt;T&gt;) {
        // We have this:
        //
        // input.front -&gt; 1 &lt;-&gt; 2 &lt;- input.back
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        //
        // Becoming this:
        //
        // list.front -&gt; A &lt;-&gt; B &lt;-&gt; 1 &lt;-&gt; 2 &lt;-&gt; C &lt;- list.back
        //                     ^
        //                    cur
        //
        unsafe {
            // We can either `take` the input's pointers or `mem::forget`
            // it. Using `take` is more responsible in case we ever do custom
            // allocators or something that also needs to be cleaned up!
            if input.is_empty() {
                // Input is empty, do nothing.
            } else if let Some(cur) = self.cur {
                // Both lists are non-empty
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                if let Some(next) = (*cur.as_ptr()).back {
                    // General Case, no boundaries, just internal fixups
                    (*next.as_ptr()).front = Some(in_back);
                    (*in_back.as_ptr()).back = Some(next);
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                } else {
                    // No next, we're appending to the back
                    (*cur.as_ptr()).back = Some(in_front);
                    (*in_front.as_ptr()).front = Some(cur);
                    self.list.back = Some(in_back);
                }
                // Index doesn't change
            } else if let Some(front) = self.list.front {
                // We're on the ghost but non-empty, append to the front
                let in_front = input.front.take().unwrap();
                let in_back = input.back.take().unwrap();

                (*front.as_ptr()).front = Some(in_back);
                (*in_back.as_ptr()).back = Some(front);
                self.list.front = Some(in_front);
            } else {
                // We're empty, become the input, remain on the ghost
                std::mem::swap(self.list, &amp;mut input);
            }

            self.list.len += input.len;
            // Not necessary but Polite To Do
            input.len = 0;
            
            // Input dropped here
        }        
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="sixth-cursors-intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="sixth-cursors-testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="sixth-cursors-intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="sixth-cursors-testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
